' /////////////////////////////////////////////////////////////////////////////{  SPI_CMD_drv_010.spin AUTHOR: Andre' LaMothe MODIFIED BY: David Betz LAST MODIFIED: 9/29/09 VERSION 0.10 COMMENTS: This the virtual SPI driver that listens to the SPI port traffic from the AVR/PIC client. The version has been slightly modified from the version in 1.11 in two ways; its been pulled out of the main dispatcher source file for modularity and a "busy" mechanism has been implemented with a few lines of code, so that the client doesn't have to time delay for actions to occur, but the driver sets a flag, so the caller can tell when a command is complete and thus when another can be processed. }' ///////////////////////////////////////////////////////////////////////////'//////////////////////////////////////////////////////////////////////////////' CONSTANTS SECTION ///////////////////////////////////////////////////////////'//////////////////////////////////////////////////////////////////////////////CON  ' SPI data line port IO index   SPI_MOSI_PORT          = 9  ' master out slave in  SPI_MISO_PORT          = 10 ' master in slave out  ' Flag to indicate that the dispatcher is busy  DISPATCHER_BUSY        = $00_ff_00_00  DISPATCHER_IDLE        = $00_00_00_00 '//////////////////////////////////////////////////////////////////////////////' VARS SECTION ////////////////////////////////////////////////////////////////'//////////////////////////////////////////////////////////////////////////////          VAR  ' ASM driver parameters section that will be passed to ASM SPI driver, order of parms needs to be consistent   long g_spi_cmdpacket ' after the SPI driver receives a complete packet, this holds the results  long g_spi_result    ' acts as the status/result storage for the SPI command parser on the SPIN side                       ' the command processor stuffs results here, and they are guaranteed to get back to host                       ' on NEXT SPI byte/cmd payload  long g_spi_busy      ' set to $00ff0000 if dispatcher is busy and $00000000 if it is idle                         ' end parameters section  long cogon, cog      ' id for cog'//////////////////////////////////////////////////////////////////////////////'OBJS SECTION /////////////////////////////////////////////////////////////////'//////////////////////////////////////////////////////////////////////////////OBJ'//////////////////////////////////////////////////////////////////////////////'PUBS SECTION /////////////////////////////////////////////////////////////////'//////////////////////////////////////////////////////////////////////////////PUB start : status  ' reset command packet  g_spi_cmdpacket := 0  ' reset result  g_spi_result := 0  ' reset busy indicator  g_spi_busy := 0  ' start the SPI virtual peripheral  status := cogon := (cog := cognew(@SPI_Driver_Entry, @g_spi_cmdpacket)) > 0PUB stop  if cogon~    cogstop(cog)PUB getcmd : cmd  ' wait for a command  repeat until (g_spi_cmdpacket & $1_00_00_00) > 0  ' return the command and its parameters  cmd := g_spi_cmdpacket & $FF_FF_FF  ' reset the command buffer  g_spi_cmdpacket := 0PUB finishcmd(spi_result)  ' set the result to return with the next command  g_spi_result := spi_result  ' finished with the current command  g_spi_busy := DISPATCHER_IDLE'//////////////////////////////////////////////////////////////////////////////' ASM SECTION /////////////////////////////////////////////////////////////////'//////////////////////////////////////////////////////////////////////////////        DAT                              org $000' Entry point                                 SPI_Driver_Entry              mov       r0, PAR                         ' copy boot parameter ptr value, all parameters start at this base address                                                        ' other pointer addresses would modify r0 and then assign to particular ptr's                                                                                ' PAR -> 0: g_spi_cmdpacket                                                        '        4: g_spi_result                                                                                                                                                                 '        8: g_spi_busy              mov       spi_cmdpacket_ptr, r0           ' spi_cmdpacket_ptr -> g_spi_cmdpacket                                                                      add       r0, #4              mov       spi_result_ptr, r0              ' spi_result_ptr -> g_spi_result              add       r0, #4              mov       spi_busy_ptr, r0                ' spi_busy_ptr -> g_spi_busy                                                                      ' each data packet/command consists of a fixed payload for simplicity, later you can do whatever you want using this driver              ' as a starting point to get you going. Considering that, the format of SPI commands is:              ' 3 bytes always with the following format: [command8, data8, status8 (data8)]              ' now the tricky part is reading "status" or getting data back in general. The SPI interface works with circular buffers,              ' so while the master processor is clocking something into this slave, the slave is clocking something out, could be garbage,              ' could be data. However, the problem is that the drivers are VERY slow compared to the SPI interface, this when the SPI interface              ' gets a command byte, it doesn't have time to execute the command AND fill the status data, thus, how we are going to perform              ' ALL read type commands, is as follows:              '              ' 1. the client/master will send a normal 3-byte payload - [command8, data8, status8 (data8)], the status8 data might be data, if              '    the client needs 16-bit operand, however, if its not needed the status8 can be anything. But, the data clocked OUT of the Prop              '    into the master/client will be garbage, that is, the drivers won't have executed the command(s) yet, but they will shortly.              '              ' 2. The SPI packet will complete, then the Prop core "listening" to messages from this SPI driver will see the requested command,              '    the listening code will then send messages to the appropriate driver, get the data requested and then place it into an outgoing              '    buffer for the SPI driver, ready to be read, by a follow up "READ" command from the master/client.              '              ' 3. Now, the master/client knowing that the previous command takes x time to complete, waits and then issues a READ command to this              '    driver, but this time, the driver already has valid results in the data buffer, and shifts it back out to the client/master.              '              ' For example, to read the keyboard, the client/master issues a read key command, but the status8 value is garbage, the client/master              ' then issues a follow up read command a moment later, and the results of the keyboard read will come back from the SPI interface! SPI_Wait_For_Cmd              ' initialize packet/command buffer              mov       spi_buffer, #0              mov       spi_cmdpacket, #0                                                               mov       r7, #3                          ' r7 = 3, loop counter, get 3 bytesSPI_Wait_For_Cmd_Loop              call      #SPI_Read_Write                 ' read/write a SPI byte, r0, r1 destroyed in call              ' shift command buffer over to receive new byte              shl       spi_cmdpacket, #8                                                 ' place byte 0 of command packet into buffer              mov       r0, spi_buffer                  ' retrieve next byte of data written to spi_buffer              and       r0, #$FF                        ' mask data off, spi_buffer might have upper bit garbage              or        spi_cmdpacket, r0               ' place byte into cmd buffer                            ' test to see if user has de-asserted SS line, if so return to top of command and reset               mov       r1, INA                         ' get inputs, test SPI SS line              and       r1, SPI_SS_MASK  wz         if_nz jmp       #SPI_Wait_For_Cmd                                          djnz      r7, #SPI_Wait_For_Cmd_Loop      ' loop while (r7 > 0)              and       spi_cmdpacket, CMD_MASK  nr, wz ' check to see if this is the NULL command         if_z waitpeq   SPI_SS_MASK, SPI_SS_MASK        ' wait for risingedge on SPI_SS line, de-assert before next command         if_z jmp       #SPI_Wait_For_Cmd              ' at this point command packet has been received, sent it up to monitor for processing              wrlong    CMD_MASK, spi_busy_ptr              or        spi_cmdpacket, SPI_CMD_RECEIVED_FLAG              wrlong    spi_cmdpacket, spi_cmdpacket_ptr ' write the value to the global listener received by SPI driver                            waitpeq   SPI_SS_MASK, SPI_SS_MASK        ' wait for risingedge on SPI_SS line, de-assert before next command              jmp       #SPI_Wait_For_CMD               ' wait for next commandSPI_Read_Write              mov       DIRA, SPI_PORT_IO_DESEL_BITS    ' set SPI ports to proper input/outputs, others to input              ' assume CPOL = 0, CPHA = 0              ' step 1: wait for SPI_SS to assert, then enable MISO, and start byte transfer loopSPI_Wait_For_SS              mov       r0, #0              waitpeq   r0, SPI_SS_MASK                 ' wait for falling edge on SPI_SS line              ' step 2: SPI_SS has been asserted, thus set IO ports to proper setting now that this SPI device is selected              or        DIRA, SPI_PORT_IO_SEL_BITS      ' set SPI ports to proper input/outputs                                              ' step 3: enter byte receive/send loop              ' **** now write into the spi_buffer the 16 bit global return value from the command processor, could be garbage              ' but we need to do this to get it back to host and also an 8 bit busy flag. If this flag is zero the dispatcher              ' is idle and ready for a new command. If it is $ff, the dispatcher is busy processing the previous command.              rdlong    r5, spi_result_ptr              ' read the sent value of the g_spi_buffer into local value                                                        ' spi_buffer = MM[ parms_base_addr_ptr ]              and       r5, WORD_MASK                   ' mask out the low order 16 bits              rdlong    r6, spi_busy_ptr                ' read the busy flag                            or        r5, r6                          ' combine the busy flag with the 16 bit result              mov       r6, #3                          ' r6 = 3                                                                sub       r6, r7                          ' r6 = 3 - r7 -> 0,1,2                         shl       r6, #3                          ' r6 = r6*8              shr       r5, r6                          ' r5 = r5 << (0,8,16:r7=3,2,1)              mov       spi_buffer, r5                  ' spi_buffer = r5                              ' place MSB on SPI_MISO port from SPI buffer              and       OUTA, nSPI_MISO_MASK            ' clear any data bit on the SPI_MISO line output              mov       r0, spi_buffer                  ' r0 = spi_buffer               and       r0, #%10000000                shl       r0, #(SPI_MISO_PORT - 8 + 1)    ' shift SPI_buffer MSB into position for operation                                                        ' r0 holds next bit of outgoing data from circular SPI buffer              or        OUTA, r0                        ' OUTA = r0, place data on pin for master to sample              ' enter bit shift loop...              mov       r1, #8                          ' counter r1 = 8SPI_Read_Loop              ' step 4: wait for SPI_CLK to rise              waitpeq   SPI_CLK_MASK, SPI_CLK_MASK      ' wait for rising edge on SPI clock                 ' let data stabilize a moment before reading it              'nop              ' for CPHA = 0 the data is sampled by master and slave on rising edge, changed on falling edge              ' step 5: retrieve next bit of data from SPI_MOSI and place into buffer              shl       spi_buffer, #1                  ' SPI_buffer = SPI_buffer << 1,     X <- xxxx_xxx0 <- 0                                                        ' make place for data in LSB, shift next MSB into position, old MSB shifted out and ignored              mov       r0, INA                         ' get data from port IO pins, the only pin we care about is SPI_MOSI (P9)              and       r0, SPI_MOSI_MASK               ' r0 = r0 & SPI_MOSI_MASK, AND mask, so we only have data bit X at P9: 0000..00 X 00...000              shr       r0, #SPI_MOSI_PORT              ' r0 = r0 >> SPI_MOSI_PORT, results in SPI_buffer = 0000_000b <- new bit b at LSB                                     or        spi_buffer, r0                  ' SPI_buffer = SPI_buffer | r0, insert shift bit into LSB                              ' step 6: wait for falling edge, place next outgoing bit on SPI_MISO line...              mov       r0, #0              waitpeq   r0, SPI_CLK_MASK                ' wait for SPI_CLK to fall              ' step 7: place next bit on SPI_MISO line and wait for next rising edge...              and       OUTA, nSPI_MISO_MASK            ' clear any data bit on the SPI_MISO line output (its already been sampled)              mov       r0, spi_buffer                  ' r0 = SPI_buffer               and       r0, #%10000000                shl       r0, #(SPI_MISO_PORT - 8 + 1)    ' shift SPI_buffer MSB into position for operation                                                        ' r0 holds next bit of outgoing data from circular SPI buffer              or        OUTA, r0                        ' OUTA = r0, place data on pin for master to sample              ' step 8: done with all 8 bits?              djnz      r1, #SPI_Read_Loop              ' while (--r1 > 0) loop               ' transmission complete              and       spi_buffer, #%0_11111111        ' mask only the desired bitsSPI_Read_Write_ret                                      ' this label *_ret is needed for assembler to bind return address properely              ret                                       ' return to caller              '//////////////////////////////////////////////////////////////////////////////' LOCAL COG VARIABLES AND CONSTANTS SECTION ///////////////////////////////////'//////////////////////////////////////////////////////////////////////////////        ' general working registersr0                     long     $0r1                     long     $0r2                     long     $0r3                     long     $0r4                     long     $0r5                     long     $0r6                     long     $0r7                     long     $0' local SPI variablesspi_buffer             long     %00000000_00000000_00000000_00000000spi_result_ptr         long     $0spi_cmdpacket          long     %00000000_00000000_00000000_00000000spi_cmdpacket_ptr      long     $0spi_busy_ptr           long     $00_00_00_00' constants pool, masks ,etc.                                ' SPI masks            SPI_PORT_IO_DIR_MASK   long     %0000_0000_0000_0000_0000_1111_0000_0000 ' SPI port AND mask, used to mask out other port bits for non-destructive port IO operationsSPI_PORT_IO_SEL_BITS   long     %0000_0000_0000_0000_0000_0100_0000_0000 ' SPI port direction bits, only a single output when selected; SPI_MISO  SPI_PORT_IO_DESEL_BITS long     %0000_0000_0000_0000_0000_0000_0000_0000 ' SPI port direction bits when chip is deselected, no outputs, all inputsnSPI_PORT_IO_DIR_MASK   long    %1111_1111_1111_1111_1111_0000_1111_1111 ' SPI port AND mask, used to mask out other port bits for non-destructive port IO operationsnSPI_PORT_IO_SEL_BITS   long    %1111_1111_1111_1111_1111_1011_1111_1111 ' SPI port direction bits, only a single output when selected; SPI_MISO  nSPI_PORT_IO_DESEL_BITS long    %1111_1111_1111_1111_1111_1111_1111_1111 ' SPI port direction bits when chip is deselected, no outputs, all inputsSPI_SS_MASK            long     %0000_0000_0000_0000_0000_0001_0000_0000 ' I/O port P8 (input), SPI chip select, active LOW SPI_MOSI_MASK          long     %0000_0000_0000_0000_0000_0010_0000_0000 ' I/O port P9 (input), SPI serial in line FROM master SPI_MISO_MASK          long     %0000_0000_0000_0000_0000_0100_0000_0000 ' I/O port P10 (output), SPI serial out line TO masterSPI_CLK_MASK           long     %0000_0000_0000_0000_0000_1000_0000_0000 ' I/O port P11 (input), SPI clock FROM masternSPI_SS_MASK           long     %1111_1111_1111_1111_1111_1110_1111_1111 ' I/O port P8 (input), SPI chip select, active LOW nSPI_MOSI_MASK         long     %1111_1111_1111_1111_1111_1101_1111_1111 ' I/O port P9 (input), SPI serial in line FROM master nSPI_MISO_MASK         long     %1111_1111_1111_1111_1111_1011_1111_1111 ' I/O port P10 (output), SPI serial out line TO masternSPI_CLK_MASK          long     %1111_1111_1111_1111_1111_0111_1111_1111 ' I/O port P11 (input), SPI clock FROM masterSPI_CMD_RECEIVED_FLAG  long     %11111111_00000000_00000000_00000000     ' holds     CMD_MASK               long     $00_ff_00_00WORD_MASK              long     $00_00_ff_ff